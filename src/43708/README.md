# 43708 - 密文搜索

![Year: 2015](https://img.shields.io/badge/Year-2015-white)
![Level: National](https://img.shields.io/badge/Level-National-purple)
![Python3](https://img.shields.io/badge/Python3-AC-green)

## 题目

### 题目描述

福尔摩斯从 X 星收到一份资料，全部是小写字母组成。

他的助手提供了另一份资料：许多长度为 8 的密码列表。

福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。

请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列可能性。

### 输入描述

输入第一行：一个字符串 $s$ ，全部由小写字母组成，长度小于 $1024 \times 1024$ 。

紧接着一行是一个整数 $n$ ，表示以下有 $n$ 行密码， $1 \leq n \leq 1000$ 。

紧接着是 $n$ 行字符串，都是小写字母组成，长度都为 8。

### 输出描述

输出一个整数，表示每行密码的所有排列在 $s$ 中匹配次数的总和。

### 输入输出样例

#### 示例

> 输入

```txt
aaaabbbbaabbcccc
2
aaaabbbb
abcabccc
```

> 输出

```txt
4
```

## 分析

本题如果按照传统方法去匹配的话，耗时较长。

由于密码被打乱后不改变各个字母出现的次数，我们不妨设定一个 ID 机制，来直接表征一个 8 字符片段中出现的各个字母的次数。

将字母表第 $l$ 个字母（ $l$ 从 0 开始）在 8 字符的字符串 $x$ 中出现的次数记作 $\text{C}(x, l)$ ，那么 ID 可以由如下公式计算（使用了八进制）：

```math
\text{ID}(x) = \sum_{l=0}^{25} (8^l \cdot \text{C}(x, l))
```

我们可以提前把密码和原文的每 8 字符片段的 ID 都算出来，然后将原文片段的 ID 与密码的 ID 进行比对，看看是否相等就行了。
