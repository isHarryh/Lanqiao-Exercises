# 43730 - 修改数组

![Year: 2019](https://img.shields.io/badge/Year-2019-white)
![Level: Provincial](https://img.shields.io/badge/Level-Provincial-blue)
![Python3](https://img.shields.io/badge/Python3-AC-green)

## 题目

### 题目描述

给定一个长度为 $N$ 的数组 $A = [A_1,A_2,··· ,A_N]$ ，数组中有可能有重复出现的整数。

现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改 $A_2,A_3,··· ,A_N$ 。

当修改 $A_i$ 时，小明会检查 $A_i$ 是否在 $A_1$ ∼ $A_i−1$ 中出现过。如果出现过，则小明会给 $A_i$ 加上 1；如果新的 $A_i$ 仍在之前出现过，小明会持续给 $A_i$ 加 1，直 到 $A_i$ 没有在 $A_1$ ∼ $A_i−1$ 中出现过。

当 $A_N$ 也经过上述修改之后，显然 $A$ 数组中就没有重复的整数了。

现在给定初始的 $A$ 数组，请你计算出最终的 $A$ 数组。

### 输入描述

第一行包含一个整数 $N$ 。

第二行包含 $N$ 个整数 $A_1,A_2,··· ,A_N$ 。

其中， $1  \leq  N  \leq  10^5，1  \leq  A_i  \leq  10^6$ 。

### 输出描述

输出 $N$ 个整数，依次是最终的 $A_1,A_2,··· ,A_N$ 。

### 输入输出样例

#### 示例

> 输入

```txt
5
2 1 1 3 4
```

> 输出

```txt
2 1 3 4 5
```

## 分析：

本题的本意是使用**并查集**。

如果使用模拟法，比较坏的情况是，当有很多重复的数字出现时，例如 `1 1 1 ... 1 1 1`，那么每次将元素加上 1 的做法非常耗时。为了优化这一点，我们引入一个 $top$ 变量，表示从 1 到 $top - 1$ 之间的所有数已经被使用过了，下一次再遇到数值小于 $top$ 的元素，就直接设置为 $top$ 就好了。当然，即使这样优化了，也是不够好的。

最好的办法是采用并查集。使用 $parent[x]$ 来表示数值 $x$ 最早能占用的下一个空位。每次查找数字 $x$ 时：

- 如果 $x$ 不在 $parent$ 中，就直接使用 $x$ ，并设置 $parent[x]$ 为 $x+1$ 。
- 如果 $x$ 已经位于 $parent$ 中，则递归查找 $parent[x]$ 。查找结束后，将 $parent[x]$ 更新为查找结果，以压缩查找路径。
