# 43731 - 糖果

![Year: 2019](https://img.shields.io/badge/Year-2019-white)
![Level: Provincial](https://img.shields.io/badge/Level-Provincial-blue)
![Python3](https://img.shields.io/badge/Python3-AC-green)

## 题目

### 题目描述

糖果店的老板一共有 $M$ 种口味的糖果出售。为了方便描述，我们将 $M$ 种口味编号 1 ∼ $M$ 。

小明希望能品尝到所有口味的糖果。遗憾的是老板并不单独出售糖果，而是 $K$
颗一包整包出售。

幸好糖果包装上注明了其中 $K$ 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。

给定 $N$ 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。

### 输入描述

第一行包含三个整数 $N,M,K$ 。

接下来 $N$ 行每行 $K$ 个整数 $T_1,T_2,···,T_K$ ，代表一包糖果的口味。

其中， $1 \leq N \leq 100, 1 \leq M \leq 20, 1 \leq K \leq 20, 1 \leq T_i \leq M$ 。

### 输出描述

输出一个整数表示答案。如果小明无法品尝所有口味，输出 −1。

### 输入输出样例

#### 示例

> 输入

```txt
6 5 3
1 1 2
1 2 3
1 1 3
2 3 5
5 4 2
5 1 2
```

> 输出

```txt
2
```

## 分析

本题可以使用**搜索或状态压缩 DP**解决。如果选项数量 $N$ 较小而状态空间 $M$ 较大，适合采用搜索法（题解 V1）；反之，则适合采用状态压缩 DP 解决（题解 V2）。就本题的规模而言，应该使用状态压缩 DP。下面介绍状态空间 DP 的解法。

每种口味的糖果具有“选择”和“不选择”两种状态，因此不妨让第 1 ~ $M$ 种糖果作为二进制的第 1 ~ $M$ 位，利用一个 $M$ 位的二进制数来存储任意一个状态。没有任何糖果的状态是 0，而所有糖果都被选上的状态是全 1（即 $2^M-1$ ）。

维护一个 $dp$ 数组，令 $dp[i]$ 表示达到状态 $i$ 所需的最少包数。初始化每个元素的值为一个足够大的数，表示“无论怎么选取都无法获得所有糖果”。特别地，初始化 $dp[0]$ 的值为 0，因为在没有糖果时，选取了 0 包糖果。

先对每包糖果 $p$ 进行遍历，再对所有状态 $i$ 进行遍历：

- 如果目前 $dp[i]$ 是那个足够大的数，表面此状态暂时无法达到，跳过。
- 否则，将这包糖果 $p$ 加入到 $i$ 里面，得到新状态 $i|p$ 。将 $dp[i|p]$ 设为 $dp[i|p]$ 与 $dp[i]+1$ 中的较小者。

遍历完成后，元素 $dp[2^M-1]$ 的值即为所求。
