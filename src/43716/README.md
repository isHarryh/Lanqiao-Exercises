# 43716 - 序列计数

![Year: 2020](https://img.shields.io/badge/Year-2020-white)
![Level: Provincial Mock](https://img.shields.io/badge/Level-Provincial%20Mock-blue)
![Python3](https://img.shields.io/badge/Python3-TLE-yellow)
![PyPy7](https://img.shields.io/badge/PyPy7-AC-green)

## 题目

### 题目描述

小明想知道，满足以下条件的正整数序列的数量：

1. 第一项为 $n$ ；
2. 第二项不超过 $n$ ；
3. 从第三项开始，每一项小于前两项的差的绝对值。

请计算，对于给定的 $n$ ，有多少种满足条件的序列。

### 输入描述

输入一行包含一个整数 $n(1 \leq n \leq 1000)$ 。

### 输出描述

输出一个整数，表示答案。答案可能很大，请输出答案除以 $10^4$ 的余数。

### 输入输出样例

#### 示例

> 输入

```txt
4
```

> 输出

```txt
7
```

> 样例说明

以下是满足条件的序列：

```
4 1
4 1 1
4 1 2
4 2
4 2 1
4 3
4 4
```

## 分析

本题可使用**DFS**来递归求解，同时可以使用**前缀和**来减少重复计算。

根据题意，每一个序列的某两个相邻数字 $a_i$ 和 $a_{i+1}$ 的绝对差值 $d=|a_i - a_{i+1}|$ 会随着 $i$ 的增大而严格单调递减。为了进一步研究序列的规律，可以先手工枚举一些情况：

```
(1)
1 1

(2)
2 2
2 1

(4)
3 3
3 2
3 1
3 1 1

(7)
4 4
4 3
4 2
4 2 1
4 1
4 1 2
4 1 1
```

这些序列可以分为两类。

1. 第一类，末尾两个数字的绝对差值为 1，此时序列不能继续往下扩展（下称“完全序列”）。例如 `3 2`。
2. 第二类，末尾两个数字的绝对差值大于 1，此时序列虽然可以继续往下扩展，但是也算一个合法序列（下称“不完全序列”）。例如 `4 1` 可以扩展为 `4 1 2` 和 `4 1 1`。

记以 $a,b$ 开头的序列的数量有 $\text{S}(a,b)$ 个，则题目需要求解 $\sum_{m=1}^n \text{S}(n,m)$ 。问题转化为 $\text{S}(a,b)$ 应该如何计算。

要想计算以 $a,b$ 开头的序列一共有多少种，搜索函数 $\text{S}$ 可以这样写：

1. 如果 $a,b$ 的绝对差值 $d$ 小于 1，表明这已经是一个完全序列。记录该序列，得到 $\text{S}(a,b) = 1$ 。
2. 否则，这是一个不完全序列。记录该序列，并递归地查找以 $b,c$ 开头的序列（其中 $c$ 是所有小于 $d$ 的正整数），得到 $\text{S}(a,b) = 1 + \sum_{c=1}^{d-1} \text{S}(b,c)$ 。

针对上述搜索函数 $\text{S}$ ，可以采取以下优化：

1. 为了避免 $\text{S}(a,b)$ 的重复性计算，不妨维护一个缓存数组 `cache[a][b]` 来记忆其相应的结果。
2. 为了避免 $\sum_{c=1}^{d-1} \text{S}(b,c)$ 的重复性计算，不妨维护一个“前缀和”数组 `prefix_sum[b][d]` 来记忆相应的求和结果。由于“前缀和”数组是逐步生成的，为了快速找到 `b` 的“前缀和”已经记录到哪一个 `d` 了，所以还需要维护一个“前缀和头部”数组 `prefix_sum_head[b]` 来记录 `prefix_sum[b][d]` 中的最大 `d` 索引值。

在 $n \rightarrow 1000$ 的情况下，上述算法采用 PyPy 运行，求解耗时小于 1s。
